es:
  seeds:
    chapters:
      basic_concepts:
        lessons:
          introduction_java:
            lesson_contents:
              welcome_java:
                content:
                  title: 'Bienvenido a Java'
                  desc: '<p>Java es un lenguaje de programación moderno y de alto nivel diseñado a principios de los años 90 por Sun Microsystems, y actualmente propiedad de Oracle.</p><p>Java es independiente de la plataforma, lo que significa que sólo hay que escribir el programa una vez para poder ejecutarlo en varias plataformas diferentes. Java es portátil, robusto y dinámico, con la capacidad de adaptarse a las necesidades de prácticamente cualquier tipo de aplicación. Java le garantiza que podrá escribir una vez y ejecutar en cualquier lugar</p>'
              java:
                content:
                  title: 'Java'
                  desc: '<p>Más de 3.000 millones de dispositivos funcionan con Java.</p><p>Java se utiliza para desarrollar aplicaciones para el sistema operativo Android de Google, diversas aplicaciones de escritorio, como reproductores multimedia, programas antivirus, aplicaciones web, aplicaciones empresariales (por ejemplo, bancarias), ¡y muchas más!</p>'
          a_hello_world_program:
            lesson_contents:
              your_first_java_program:
                content:
                  title: 'Tu primer programa Java'
                  desc: '<p>Empecemos por crear un programa sencillo que imprima "Hola Mundo" en la pantalla.</p><div><code><p>class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">System.out.println("Hello World");</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>En Java, cada línea de código que pueda ejecutarse debe estar dentro de una clase. En nuestro ejemplo, hemos llamado a la clase MyClass. Aprenderás más sobre las clases en los próximos módulos.</p><p>En Java, cada aplicación tiene un punto de entrada, o un punto de partida, que es un método llamado main. Junto con main, las palabras clave public y static también se explicarán más adelante.</p><p>A modo de resumen:<br/> - Todo programa en Java debe tener una clase.<br/> - Todo programa en Java comienza con el método main.</p>'
              the_main_method:
                content:
                  title: 'El método main'
                  desc: '<p>Para ejecutar nuestro programa, el método principal debe ser idéntico a esta firma:</p><div><code><p>public static void main(String[ ] args)</p></code></div><p>- público: cualquiera puede acceder a él<br/> - static: el método puede ejecutarse sin crear una instancia de la clase que contiene el método principal<br/>- void: el método no devuelve ningún valor<br/> - main: el nombre del método<br/></p><p>Por ejemplo, el siguiente código declara un método llamado test, que no devuelve nada y no tiene parámetros:</p><div><code><p>void test()</p></code></div><p>Los parámetros del método se declaran dentro de los paréntesis que siguen al nombre del método. <br/>En el caso de main, es un array de cadenas llamado args. Lo usaremos en nuestra próxima lección, así que no te preocupes si no lo entiendes todo ahora.</p>'
              system_out_println:
                content:
                  title: 'System.out.println()'
                  desc: '<p>A continuación está el cuerpo del método main, delimitado entre llaves:</p><div><code><p>{</p> <p>System.out.println("Hello World!");</p><p>}</p></code></div><p>El método println imprime una línea de texto en la pantalla. <br/>La clase System y su flujo de salida se utilizan para acceder al método println.</p><p>En las clases, métodos y otras estructuras de control de flujo, el código siempre se encierra entre llaves { }.</p>'
              semicolon_in_java:
                content:
                  title: 'Punto y coma en Java'
                  desc: '<p>Puedes pasar un texto diferente como parámetro al método println para imprimirlo.</p><div><code><p>class MyClass {</p> <p style="text-indent: 1%">public static void main(String[ ] args) {</p> <p style="text-indent: 2%">System.out.println("I am learning Java");</p> <p style="text-indent: 1%">}</p><p>}</p></code></div><p>En Java, cada declaración de código debe terminar con un punto y coma.</p><p>Recuerde: no use punto y coma después de las declaraciones de métodos y clases que siguen con el cuerpo definido usando las llaves.</p>'
          java_comments:
            lesson_contents:
              comments:
                content:
                  title: 'Comentarios'
                  desc: '<p>El propósito de incluir comentarios en su código es explicar lo que el código está haciendo.</p><p>Java admite comentarios de una o varias líneas. Todos los caracteres que aparecen dentro de un comentario son ignorados por el compilador de Java.</p><p>Un comentario de una línea comienza con dos barras inclinadas y continúa hasta el final de la línea.</p><p>Por ejemplo:</p><div><code><p>// este es un comentario de una sola línea</p><p>x = 5; // un comentario de una sola línea después del código</p></code></div><p>Añadir comentarios a medida que se escribe el código es una buena práctica, ya que proporcionan aclaración y comprensión cuando se necesita volver a consultarlo, así como para otros que puedan necesitar leerlo.</p>'
              multiline_comments:
                content:
                  title: 'Comentarios multilínea'
                  desc: '<p>Java también admite comentarios que abarcan varias líneas.<br/>Este tipo de comentario comienza con una barra inclinada seguida de un asterisco y termina con un asterisco seguido de una barra inclinada.<br/></p><p>Por ejemplo:</p><div><code><p>/* Esto también es un</p><p>comentario que abarca</p><p>varias líneas */</p></code></div><p>Tenga en cuenta que Java no admite los comentarios multilínea anidados.<br/>Sin embargo, se pueden anidar comentarios de una línea dentro de comentarios de varias líneas.</p><div><code><p>/* Este es un comentario de una sola línea:</p><p>// un comentario de una sola línea</p><p>*/</p></code></div><p>Otro nombre para un Multi-Line comment (comentario de varias líneas) es un Block comment.</p>'
              documentation_comments:
                content:
                  title: 'Comentarios de documentación'
                  desc: '<p>Los comentarios de documentación son comentarios especiales que tienen la apariencia de los comentarios de varias líneas, con la diferencia de que generan documentación externa de su código fuente. Empiezan con una barra diagonal seguida de dos asteriscos y terminan con un asterisco seguido de una barra diagonal.</p><p>Por ejemplo:</p><div><code><p>/** This is a documentation comment */</p><p>/** This is also a</p><p>documentation comment */</p></code></div><p>Javadoc es una herramienta que viene con el JDK y se utiliza para generar la documentación del código Java en formato HTML a partir del código fuente Java que tiene la documentación necesaria en un formato predefinido.</p><p>Cuando un comentario de documentación comienza con más de dos asteriscos, Javadoc asume que usted quiere crear una "caja" alrededor del comentario en el código fuente. <br/>Simplemente ignora los asteriscos adicionales.</p><p>Por ejemplo:</p><div><code><p>/**********************</p><p>Este es el inicio de un método</p><p>***********************/</p></code></div><p>Esto mantendrá sólo el texto "Este es el comienzo de un método" para la documentación.</p>'
          variables:
            lesson_contents:
              variables:
                content:
                  title: 'Variables'
                  desc: '<p>Las variables almacenan datos para su procesamiento.</p><p>A una variable se le asigna un nombre (o identificador), como área, edad, altura y similares. <br/>El nombre identifica de forma única cada variable, asignando un valor a la variable y recuperando el valor almacenado.</p><p>Las variables tienen tipos. Algunos ejemplos:<br/>- int: para los enteros (números enteros) como 123 y -456<br/>- double: para números de punto flotante o reales con puntos decimales opcionales y partes fraccionarias en notaciones fijas o científicas, como 3,1416, -55,66.<br/>- String: para textos como "Hola" o "¡Buenos días!". Las cadenas de texto van entre comillas dobles.</p><p>Puede declarar una variable de un tipo y asignarle un valor.</p><p>Ejemplo:</p><div><code><p>String name = "David";</p></code></div><p>Esto crea una variable llamada nombre de tipo String, y le asigna el valor "David".</p><p>Es importante tener en cuenta que una variable está asociada a un tipo, y sólo es capaz de almacenar valores de ese tipo concreto. <br/>Por ejemplo, una variable int puede almacenar valores enteros, como 123; pero no puede almacenar números reales, como 12,34, o textos, como "Hola".</p><p>Ejemplos de declaraciones de variables:</p><div><code><p>class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">String name ="David";</p><p style="text-indent: 2%">int age = 42;</p><p style="text-indent: 2%">double score =15.9;</p><p style="text-indent: 2%">char group = "Z";</p><p style="text-indent: 2%">}</p><p>}</p></code></div><p>char significa carácter y contiene un solo carácter.</p><p>Otro tipo es el Boolean, que sólo tiene dos valores posibles: verdadero y falso.<br/>Este tipo de datos se utiliza para banderas simples que registran condiciones verdadero/falso.</p><p>Por ejemplo:</p><div><code><p>boolean online = true;</p></code></div><p>Puede utilizar una lista separada por comas para declarar más de una variable del tipo especificado. Ejemplo: int a = 42, b = 11;</p>'
          obtaining_user_input:
            lesson_contents:
              obtaining_user_input:
                content:
                  title: 'Obteniendo entrada del usuario'
                  desc: '<p>Aunque Java proporciona muchos métodos diferentes para obtener la entrada del usuario, el objeto Scanner es el más común, y quizás el más fácil de implementar. </br>Importe la clase Scanner para utilizar el objeto Scanner, como se ve aquí:</p><div><code><p>import java.util.Scanner;</p></code></div><p>Para utilizar la clase Scanner, cree una instancia de la clase utilizando la siguiente sintaxis:</p><div><code><p>Scanner myVar = new Scanner(System.in);</p></code></div><p>Ahora puede leer en diferentes tipos de datos de entrada que el usuario introduce. Aquí hay algunos métodos que están disponibles a través de la clase Scanner:</p><p><ul><li>Leer un byte - nextByte()</li><li>Leer un short - nextShort()</li><li>Leer un int - nextInt()</li><li>Leer un long - nextLong()</li><li>Leer un float - nextFloat()</li><li>Leer un double - nextDouble()</li><li>Leer un boolean - nextBoolean()</li><li>Leer una línea completa - nextLine()</li><li>Leer una palabra - next()</li></ul></p><p>Ejemplo de un programa utilizado para obtener la entrada del usuario:</p><div><code><p>import java.util.Scanner;</p><br/><p>class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Scanner myVar = new Scanner(System.in);</p><p style="text-indent: 2%">System.out.println(myVar.nextLine());</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Esto esperará a que el usuario introduzca algo e imprimirá esa entrada.<br/>El código puede parecer complejo, pero lo entenderás todo en las próximas lecciones.</p>'
          primitive_operators:
            lesson_contents:
              mathematical_operators:
                content:
                  title: 'Los operadores matemáticos'
                  desc: '<p>Java proporciona un rico conjunto de operadores para utilizar en la manipulación de variables. Un valor utilizado en cualquier lado de un operador se llama operando.</p><p>Por ejemplo, en la expresión siguiente, los números 6 y 3 son operandos del operador más:</p><div><code><p>int x = 6 + 3;</p></code></div><p>Operadores aritméticos de Java:</p><p><ul><li>+ suma</li><li>- resta</li><li>* multiplicación</li><li>/ división</li><li>% módulo</li></ul></p><p>Los operadores aritméticos se utilizan en las expresiones matemáticas del mismo modo que en las ecuaciones algebraicas.</p>'
              addition:
                content:
                  title: 'Suma'
                  desc: '<p>El operador + suma dos valores, como dos constantes, una constante y una variable, o una variable y una variable. He aquí algunos ejemplos de adición:</p><div><code><p>int sum1 = 50 + 10;<br/>int sum2 = sum1 + 66;<br/>int sum3 = sum2 + sum2;<br/></p></code></div>'
              subtract:
                content:
                  title: 'Resta'
                  desc: '<p>El operador - resta un valor de otro.</p><div><code><p>int res1 = 1000 - 10;<br/>int res2 = res1 - 5;<br/>int res3 = res1 - res2;<br/></p></code></div>'
              multiplication:
                content:
                  title: 'Multiplicación'
                  desc: '<p>El operador * multiplica dos valores.</p><div><code><p>int mul1 = 1000 * 2;<br/>int mul2 = mul1 * 10;<br/>int mul3 = mul1 * mul2;<br/></p></code></div>'
              division:
                content:
                  title: 'División'
                  desc: '<p>El operador / divide un valor entre otro.</p><div><code><p>int div1 = 1000 / 5;<br/>int div2 = div1 / 2;<br/>int div3 = div1 / div2;<br/></p></code></div><p>En el ejemplo anterior, el resultado de la ecuación de la división será un número entero, ya que se utiliza int como tipo de datos. Puede utilizar double para recuperar un valor con un punto decimal.</p>'
              module:
                content:
                  title: 'Módulo'
                  desc: '<p>La operación matemática de módulo (o resto) realiza una división entera de un valor por otro, y devuelve el resto de esa división.<br/>El operador de la operación de módulo es el carácter de porcentaje (%).</p><p>Ejemplo</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int value = 23;</p><p style="text-indent: 2%">int res = value % 6;</p><p style="text-indent: 2%">System.out.println(res);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Al dividir 23 entre 6 se obtiene un cociente de 3, con un resto de 5. Así, el valor de 5 se asigna a la variable res.</p>'
          increase_decrease:
            lesson_contents:
              increment_operators:
                content:
                  title: 'Operadores de incremento'
                  desc: '<p>Un operador de incremento o decremento proporciona una manera más conveniente y compacta de aumentar o disminuir el valor de una variable en uno.<br/>Por ejemplo, la sentencia x=x+1; puede simplificarse a ++x;</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int test = 5;</p><p style="text-indent: 2%">++test;</p><p style="text-indent: 2%">System.out.println(test);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El operador de decremento (--) se utiliza para disminuir el valor de una variable en uno.</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int test = 5;</p><p style="text-indent: 2%">--test;</p><p style="text-indent: 2%">System.out.println(test);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Utilice este operador con precaución para evitar errores de cálculo.</p>'
              prefix_suffix:
                content:
                  title: 'Prefijo y sufijo'
                  desc: '<p>Se pueden utilizar dos formas, prefijo y postfijo, con los operadores de incremento y decremento.<br/>Con la forma de prefijo, el operador aparece antes del operando, mientras que en la forma de sufijo, el operador aparece después del operando. A continuación se explica cómo funcionan las dos formas:</p><p>Prefijo: Incrementa el valor de la variable y utiliza el nuevo valor en la expresión.</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 2%">public static void main(String[] args) {</p><p style="text-indent: 3%">int x = 34;</p><p style="text-indent: 3%">int y = ++x;</p><p style="text-indent: 3%">System.out.println(y);</p><p style="text-indent: 2%">}</p><p>}</p></div></code><p>El valor de x se incrementa primero a 35, y luego se asigna a y, por lo que los valores de x e y son ahora 35.</p><p>Sufijo: El valor de la variable se utiliza primero en la expresión y luego se incrementa.</p><p>Sufijo: El valor de la variable se utiliza primero en la expresión y luego se incrementa.</p><div><code><p>public class Program {</p><p style="text-indent: 2%">public static void main(String[] args) {</p><p style="text-indent: 3%">int x = 34;</p><p style="text-indent: 3%">int y = x++;</p><p style="text-indent: 3%">System.out.println(y);</p><p style="text-indent: 2%">}</p><p>}</p></div></code><p>Primero se asigna “x” a “y”, y luego se incrementa en uno. Por lo tanto, “x” se convierte en 35, mientras que a “y” se le asigna el valor de 34.</p><p>Lo mismo ocurre con el operador de decremento.</p>'
              assignment_operators:
                content:
                  title: 'Operadores de asignación'
                  desc: '<p>Ya conoce el operador de asignación (=), que asigna un valor a una variable.</p><div><code><p>int value = 5;</p></code></div><p>Esto asignó el valor 5 a una variable llamada valor de tipo int.</p><p>Java proporciona una serie de operadores de asignación para facilitar la escritura de código.</p><h4>Suma y asignación (+=):</h4><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int num1 = 4;</p><p style="text-indent: 2%">int num2 = 8;</p><p style="text-indent: 2%">num2 += num1; // num2 = num2 + num1;</p><p style="text-indent: 2%">// num2 es 12 y num1 es 4</p><p style="text-indent: 2%">System.out.println(num2);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><h4>Sustracción y asignación (-=):</h4><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int num1 = 4;</p><p style="text-indent: 2%">int num2 = 8;</p><p style="text-indent: 2%">num2 -= num1; // num2 = num2 - num1;</p><p style="text-indent: 2%">// num2 es 4 y num1 es 4</p><p style="text-indent: 2%">System.out.println(num2);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Del mismo modo, Java admite la multiplicación y la asignación (*=), la división y la asignación (/=), y el resto y la asignación (%=).</p>'
          strings:
            lesson_contents:
              strings:
                content: 
                  title: 'Strings'
                  desc: '<p>Un string (cadena de texto) es un objeto que representa una secuencia de caracteres.</p>
                  <p>Por ejemplo, "Hola" es una cadena de 4 caracteres.</p>
                  <p>Por ejemplo:</p>
                  <div><code><p>String s = "HolaMundo"; </p></code></div>
                  <pSe permite definir una cadena vacía. Por ejemplo, String str = "";</p>
                  '
              string_concatenation:
                content:
                  title: 'Concatenación de Strings'
                  desc: '<p>El operador + (suma) entre cadenas de texto las junta para formar una nueva cadena de texto. Este proceso se llama concatenación.<br/>La cadena de texto resultante es la primera unida a la segunda.</p><p>Por ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">String firstName, lastName;</p><p style="text-indent: 2%">firstName = "David";</p><p style="text-indent: 2%">lastName = "Williams";</p><p style="text-indent: 2%">System.out.println("My name is " + firstName +" "+lastName);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El tipo de datos char representa un solo carácter.</p>'
      conditionals_loops:
        lessons:
          conditional_statements:
            lesson_contents:
              decision_making:
                content:
                  title: 'Toma de decisiones'
                  desc: '<p>Las declaraciones condicionales son usadas para ejecutar acciones diferentes basadas en condiciones diferentes.</p><p>La declaración if es una de las declaraciones condicionales más frecuente utilizadas.</p><p>Si la expresión condicional de la declaración if evalúa a true (verdadero), el bloque de código dentro de la declaración if es ejecutado. Si la expresión evalúa a false (falso), el primer conjunto de código después del final de la declaración if (después de las llaves de cierre) es ejecutado.</p><p>Sintaxis:</p><div><code><p>if (condition) {</p><p style="text-indent: 1%">//Se ejecuta cuando la condición es verdadera</p><p>}</p></code></div><p>Cualquier de los siguientes operadores de comparación pueden ser utilizados para formar la condición:</p><p><ul><li>< menor que</li><li>> mayor que</li><li>!= no igual que</li><li>== igual que</li><li><= menor o igual que</li><li>>= mayor o igual que</li></ul></p><p>Por ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int x = 7;</p><p style="text-indent: 2%">if(x < 42) {</p><p style="text-indent: 3%">System.out.println("Hi");</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Recuerda que necesitas utilizas dos signos de igual (==) para probar equidad, ya que un solo signo de igual es el operador asignación.</p>'
              if_else_statements:
                content:
                  title: 'Las declaraciones if... else'
                  desc: '<p>Una declaración if puede venir seguida por una declaración opcional else, la cual se ejecuta cuando la condición se evalúa como falsa.</p><p>Por ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int age = 30;</p><p style="text-indent: 2%">if (age < 16) {</p><p style="text-indent: 3%">System.out.println("Too Young");</p><p style="text-indent: 2%">} else {</p><p style="text-indent: 3%">System.out.println("Welcome!");</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Como "age" es igual a 30, la condición en la declaración if evalúa a falso y la declaración else es ejecutada.</p>'
          nested_if_statements:
            lesson_contents:
              nested_if_statements:
                content:
                  title: 'Declaraciones if anidadas'
                  desc: '<p>Puedes utilizar una declaración if-else dentro de otra declaración if o else.</p><p>Por ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int age = 25;</p><p style="text-indent: 2%">if(age > 0) {</p><p style="text-indent: 3%">if(age > 16) {</p><p style="text-indent: 4%">System.out.println("Welcome!");</p><p style="text-indent: 3%">} else {</p><p style="text-indent: 4%">System.out.println("Too Young");</p><p style="text-indent: 3%">}</p><p style="text-indent: 2%">} else {</p><p style="text-indent: 3%">System.out.println("Error");</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Puedes anidar tantas declaraciones if-else como quieras.</p>'
          else_if_statement:
            lesson_contents:
              else_if_statement:
                content:
                  title: 'La declaración else if'
                  desc: '<p>En lugar de utilizar declaraciones if-else anidadas, puedes utilizar la declaración else if para validar varias condiciones.</p><p>Por ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int age = 25;</p><p style="text-indent: 2%">if(age <= 0) {</p><p style="text-indent: 3%">System.out.println("Error");</p><p style="text-indent: 2%">} else if(age <= 16) {</p><p style="text-indent: 3%">System.out.println("Too Young");</p><p style="text-indent: 2%">} else if(age < 100) {</p><p style="text-indent: 3%">System.out.println("Welcome!");</p><p style="text-indent: 2%">} else {</p><p style="text-indent: 3%">System.out.println("Really?");</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</code></div><p>Este código validará la condición para evaluar a verdadero y ejecutar las declaraciones dentro de ese bloque.</p>'            
          logical_statements:
            lesson_contents:
              logical_operators:
                content:
                  title: 'Operadores lógicos'
                  desc: '<p>Los operadores lógicos son utilizados para combinar varias condiciones.</p><p>Digamos que quieres que tu programa imprima "Welcome!" sólo cuando la variable age sea mayor que 18 y la variable money sea mayor que 500.<br/>Una manera de lograr esto es usando declaraciones if anidadas:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int age = 22;</p><p style="text-indent: 2%">int money = 800;</p><p style="text-indent: 2%">if (age > 18) {</p><p style="text-indent: 3%">if (money > 500) {</p><p style="text-indent: 4%">System.out.println("Welcome!");</p><p style="text-indent: 3%">}</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Sin embargo, utilizando el operador lógico AND (&&) es una mejor manera:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int age = 22;</p><p style="text-indent: 2%">int money = 800;</p><p style="text-indent: 2%">if (age > 18 && money > 500) {</p><p style="text-indent: 3%">System.out.println("Welcome!");</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Si ambos operandos del operador AND son verdaderos, entonces la condición resulta verdadera.</p>'
              or_operator:
                content:
                  title: 'El operador OR'
                  desc: '<p>El operador OR (||) valida si cualquiera de las condiciones es verdadera. <br/>La condición resulta verdadera, si cualquier de los operandos evalúa a verdadero.</p><p>Por ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int age = 25;</p><p style="text-indent: 2%">int money = 100;</p><p style="text-indent: 2%">if (age > 18 || money > 500) {</p><p style="text-indent: 3%">System.out.println("Welcome!");</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El código anterior imprimirá "Welcome!" si "age" es mayor que 18 ó si "money" es mayor que 500.</p><p>El operador lógico NOT (!) es utilizado para revertir el estado lógico de su operando.<br/> Si una condición es verdadera, el operador lógico NOT la convertirá en falsa.</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int age = 25;</p><p style="text-indent: 2%">if(!(age > 18)) {</p><p style="text-indent: 3%">System.out.println("Too Young");</p><p style="text-indent: 2%">} else {</p><p style="text-indent: 3%">System.out.println("Welcome");</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>!(age > 18) se lee como "si age NO es mayor que 18".</p>'                    
          switch_statement:
            lesson_contents:
              switch_statement:
                content:
                  title: 'La declaración switch'
                  desc: '<p>Una declaración switch válida una variable por igualdad contra una lista de valores. Cada valor es llamado un case, y la variable que está siendo evaluada es comparada contra cada case.</p><p>Sintaxis:</p><div><code><p>switch (expression) {</p><p style="text-indent: 1%">case value1 :</p><p style="text-indent: 2%">//Declaraciones</p><p style="text-indent: 2%">break; //opcional</p><p style="text-indent: 1%">case value2 :</p><p style="text-indent: 2%">//Declaraciones</p><p style="text-indent: 2%">break; //opcional</p><p style="text-indent: 2%">//Puede tener cualquier número de declaraciones de caso.</p><p style="text-indent: 1%">default : //opcional</p><p style="text-indent: 2%">//Declaraciones</p><p>}</p></code></div><p><ul><li>Cuando la variable que está siendo evaluada es igual que un case, las declaraciones que siguen a ese case serán ejecutadas hasta que una declaración break es alcanzada.</li><li>Cuando una declaración break es alcanzada, el switch finaliza y el flujo de control salta a la siguiente línea después de la declaración switch.</li><li>No todos los case necesitan contener un break. Si no aparece un break, el flujo de control seguirá a través de los cases subsiguientes hasta que se alcance un break.</li></ul></p><p>El siguiente ejemplo valida day contra un conjunto de valores e imprime un mensaje correspondiente.</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int day = 3;</p><p style="text-indent: 2%">switch(day) {</p><p style="text-indent: 3%">case 1:</p><p style="text-indent: 4%">System.out.println("Monday");</p><p style="text-indent: 4%">break;</p><p style="text-indent: 3%">case 2:</p><p style="text-indent: 4%">System.out.println("Tuesday");</p><p style="text-indent: 4%">break;</p><p style="text-indent: 3%">case 3:</p><p style="text-indent: 4%">System.out.println("Wednesday");</p><p style="text-indent: 4%">break;</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Puedes tener cualquier número de declaraciones case dentro de un switch. Cada case es seguido por el valor a comparar y dos puntos.</p>'
              default_statement:
                content:
                  title: 'La declaración default'
                  desc: '<p>Una declaración switch puede tener un case default opcional.<br/>La declaración default puede ser utilizada para realizar una actividad cuando ningunos de los cases es igualado.</p><p>Por ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int day = 3;</p><p style="text-indent: 2%">switch(day) {</p><p style="text-indent: 3%">case 6:</p><p style="text-indent: 4%">System.out.println("Saturday");</p><p style="text-indent: 4%">break;</p><p style="text-indent: 3%">case 7:</p><p style="text-indent: 4%">System.out.println("Sunday");</p><p style="text-indent: 4%">break;</p><p style="text-indent: 3%">default:</p><p style="text-indent: 4%">System.out.println("Weekday");</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>No se necesita un break en el case default, ya que siempre es la última declaración en el switch.</p>'
              switch_expression:
                content:
                  title: 'La expresión switch'
                  desc: '<p>La expresión switch permite múltiples valores separados por comas por caso y devuelve un valor para todo el bloque de caso-switch.</p><p>Por ejemplo: </p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int day = 2;</p><p style="text-indent: 2%">String dayType  = switch(day) {</p><p style="text-indent: 3%">case 1, 2, 3, 4, 5 -> "Working day";</p><p style="text-indent: 3%">case 6, 7 -> "Weekend";</p><p style="text-indent: 3%">default -> "Invalid day";</p><p style="text-indent: 3%">};</p><p style="text-indent: 2%">System.out.println(dayType);</p><p style="text-indent: 1%">}</p><p>}</p></p></code></div><p>La expresión switch hace que el bloque del caso-switch sea mucho más corta y no utiliza una declaración break.</p><p>Ten en cuenta la abreviatura -> después de los casos.</p>'                                   
          loops_while:
            lesson_contents:
              loops_while:
                content:
                  title: 'Bucles while'
                  desc: '<p>Un bucle (loop) permite ejecutar repetidamente una declaración o grupo de declaraciones.</p><p>Un bucle while ejecuta repetidamente una declaración siempre que una condición dada sea verdadera.</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int x = 3;</p><p style="text-indent: 2%">while(x > 0) {</p><p style="text-indent: 3%">System.out.println(x);</p><p style="text-indent: 3%">x--;</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El bucle while valida la condición x > 0. Si evalúa a verdadero (true), ejecutará las declaraciones dentro de su cuerpo. Luego valida la condición nuevamente y se repite el proceso.</p><p>Fíjate en la declaración x--. Esta disminuye a "x" cada vez que el bucle es ejecutado y hace que el bucle se detenga cuando "x" llega a 0.<br/>Sin esa declaración, el bucle se ejecutaría sin fin.</p><p>Cuando la expresión es probada y el resultado sea falso (false), el cuerpo del bucle es omitido y la primera declaración después del bucle while es ejecutada.</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int x = 6;</p><p style="text-indent: 2%">while( x < 10 ){</p><p style="text-indent: 3%">System.out.println(x);</p><p style="text-indent: 3%">x++;</p><p style="text-indent: 2%">}</p><p style="text-indent: 2%">System.out.println("Loop ended");</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Fíjate que el último método print se encuentra fuera del scope(ámbito) while.</p>'          
          loops_for:
            lesson_contents:
              loops_for:
                content:
                  title: 'Bucles for'
                  desc: '<p>Otra estructura de bucle es el bucle for. Un bucle for te permite escribir eficientemente un bucle que necesita ser ejecutado un número específico de veces.</p><p>Sintaxis:</p><div><code><p>for (initialization; condition; increment/decrement) {</p><p style="text-indent: 1%">statement(s)</p><p>}</p></code></div><p>Inicialización: Esta expresión se ejecuta sólo una vez al comienzo del bucle.<br/>Condición: Es evaluada cada vez que itera el bucle. El bucle ejecuta la declaración repetidamente, hasta que esta condición retorne falso.<br/>Incremento/Decremento: Se ejecuta después de cada iteración del bucle.</p><p>El siguiente ejemplo imprime los números del 1 al 5.</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">for(int x = 1; x <=5; x++) {</p><p style="text-indent: 3%">System.out.println(x);</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Este código inicializa "x" con el valor de 1 y repetidamente se imprime el valor de "x" hasta que la condición x<=5 resulte falsa. En cada iteración, la declaración x++ es ejecutada, incrementando x en uno.</p><p>Fíjate en el punto y coma (;) después de la inicialización y la condición en la sintaxis.</p><p>Puedes tener cualquier tipo de condición y cualquier tipo de incremento en el bucle for.</p><p>El siguiente ejemplo imprime sólo los valores pares entre 0 y 10:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">for(int x=0; x<=10; x=x+2) {</p><p style="text-indent: 3%">System.out.println(x);</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Un bucle for es mejor cuando son conocidos los números de inicio y fin.</p>'         
          loops_do_while:
            lesson_contents:
              loops_do_while:
                content:
                  title: 'Bucles do ...while'
                  desc: '<p>Un bucle do...while es similar a un bucle while, excepto que en un bucle do...while está garantizado que será ejecutado al menos una vez.</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int x = 1;</p><p style="text-indent: 2%">do {</p><p style="text-indent: 3%">System.out.println(x);</p><p style="text-indent: 3%">x++;</p><p style="text-indent: 2%">} while(x < 5);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Fíjate que la condición aparece al final del bucle, por lo que las declaraciones en el bucle se ejecutan una vez antes de ser evaluada.</p><p>Incluso con una condición falsa, el código será ejecutado una vez.</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int x = 1;</p><p style="text-indent: 2%">do {</p><p style="text-indent: 3%">System.out.println(x);</p><p style="text-indent: 3%">x++;</p><p style="text-indent: 2%">} while(x < 0);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Fíjate que en los loops do...while, while sólo es la condición y no tiene un body (cuerpo) por sí mismo.</p>'                            
              loop_control_statements:
                content:
                  title: 'Declaraciones de control de bucles'
                  desc: '<p>Las declaraciones break y continue cambian el flujo de ejecución del bucle.<br>La declaración break finaliza la ejecución del bucle y transfiere la ejecución a la declaración que sigue inmediatamente al bucle.</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int x = 1;</p><p style="text-indent: 2%">while(x > 0) {</p><p style="text-indent: 3%">System.out.println(x);</p><p style="text-indent: 3%">if(x == 4) {</p><p style="text-indent: 4%">break;</p><p style="text-indent: 3%">}</p><p style="text-indent: 3%">x++;</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>La declaración continue produce que el bucle omita el resto de sus declaraciones y evalúe nuevamente su condición antes de reiterar.  En otras palabras, hace que el bucle salte a su próxima iteración.</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">for(int x=10; x<=40; x=x+10) {</p><p style="text-indent: 3%">if(x == 30) {</p><p style="text-indent: 4%">continue;</p><p style="text-indent: 3%">}</p><p style="text-indent: 3%">System.out.println(x);</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Como puedes ver, el código anterior salta el valor de 30, tal y como es indicado por la declaración continue.</p>'
      arrays:
        lessons:
          arrays:
            lesson_contents:
              arrays:
                content:
                  title: 'Matrices'
                  desc: '<p>Una matriz es una colección de variables del mismo tipo.<br/> Cuando necesita almacenar una lista de valores, como números, puedes almacenarlos en un matriz, en lugar de declarar variables por separado para cada número.</p><p>Para declarar un matriz, necesitas definir el tipo de los elementos junto con corchetes.</p><p>Por ejemplo, para declarar un matriz de enteros:</p><div><code><p>int[ ] arr;</p></code></div><p>El nombre del matriz es arr. El tipo de elemento que almacenará es int.</p><p>Ahora, necesitas definir la capacidad del matriz, o el número de elementos que podrá almacenar. Para lograr esto, utiliza la palabra clave new.</p><div><code><p>int[ ] arr = new int[5];</p></code></div><p>El código anterior declara un matriz de 5 enteros.<br/>En un matriz, los elementos están ordenados y cada uno tiene una posición específica y constante, la cual es llamada índice.</p><p>Para hacer referencia a los elementos en un matriz, ingresa el nombre del matriz seguido por el índice entre corchetes</p><p>Ejemplo:</p><div><code><p>arr[2] = 42;</p></code></div><p>Este código asigna un valor de 42 al elemento con índice igual a 2.</p><p>Fíjate que los elementos en el matriz están identificados con índices numerados desde el cero, lo que significa que el índice del primer elemento es 0 en lugar de 1. Por lo tanto, el mayor índice del matriz int[5] es 4.</p>'
              initializing_arrays:
                content:
                  title: 'Inicializando matrices'
                  desc: '<p>Java provee un atajo para instanciar matrices de tipos primitivos y cadenas de texto (strings).<br/>Si tú sabes de antemano qué valores vas a insertar dentro del matriz, puedes usar un matriz literal.<br/>Un ejemplo de un matriz literal:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">String[ ] myNames = { "A", "B", "C", "D"};</p><p style="text-indent: 2%">System.out.println(myNames[2]);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Coloca los valores en una lista separada por comas, delimitada dentro de llaves.<br/> El código anterior automáticamente inicializa una matriz que contiene 4 elementos y almacena los valores indicados.</p><p>Algunas veces puedes encontrar los corchetes colocados después del nombre del matriz, que también funciona, pero la manera preferida es colocar los corchetes después del tipo de dato del matriz.</p>'            
          adding_elements_arrays:
            lesson_contents:     
              array_length:
                content:
                  title: 'Longitud de la matriz'
                  desc: '<p>Puedes acceder a la longitud de un matriz (el número de elementos que almacena) a través de su propiedad length. </p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int[ ] intArr = new int[5];</p><p style="text-indent: 2%">System.out.println(intArr.length);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>No te olvides que en los arrays los índices empiezan a partir de 0. Así, en el ejempo anterior, el último índice es 4.</p>'          
              arrays:
                content:
                  title: 'Matrices'
                  desc: '<p>Ahora que sabemos cómo fijar y obtener los elementos de un matriz, podemos calcular la suma de todos los elementos en un matriz utilizando bucles.</p><p>El bucle for es el más usado cuando se trabaja con matrices, ya que podemos utilizar la longitud (length) del matriz para determinar cuántas veces ejecutamos el bucle.</p><div><code></code></div><p>En el código anterior, hemos declarado una variable sum para almacenar el resultado y le hemos asignado el valor 0.<br/>Luego, utilizamos un bucle for para iterar a través del matriz y sumamos el valor de cada elemento a la variable.</p><p>La condición del bucle for es x < myArr.length, ya que el índice del último elemento es myArr.length-1.</p>'   
          improved_for_loop:
            lesson_contents:
              improved_for_loop:
                content:
                  title: 'Bucle for mejorado'
                  desc: '<p>El bucle for mejorado (a veces llamado un bucle "for each") es utilizado para recorrer los elementos en los matrices. Las ventajas son que elimina la posibilidad de errores en el código y lo hace más sencillo de leer.</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int[ ] primes = {2, 3, 5, 7};</p><p style="text-indent: 2%">for (int t: primes) {</p><p style="text-indent: 3%">System.out.println(t);</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El bucle for mejorado declara una variable de un tipo compatible con los elementos del matriz que está siendo accesado. La variable estará disponible dentro del bloque for y su valor será el mismo que el del elemento actual del matriz.</p><p>Por lo tanto, en cada iteración del bucle, la variable t será igual al elemento correspondiente en el matriz.</p><p>Fíjate en los dos puntos después de la variable en la sintaxis.</p>'                     
          multidimensional_arrays:
            lesson_contents: 
              multidimensional_arrays:
                content:
                  title: 'Matrices multidimensionales'
                  desc: '<p>Matrices multidimensionales son matrices que contienen otros matrices. El matriz bidimensional es el matriz multidimensional más básico. </p><p>Para crear matrices multidimensionales, coloca cada matriz dentro de su propio conjunto de llaves.</p><p>Un ejemplo de un matriz bidimensional:</p><div><code><p>int[ ][ ] sample = { {1, 2, 3}, {4, 5, 6} };</p></code></div><p>Esto declara un matriz con dos matrices como sus elementos. Para acceder un elemento en el matriz bidimensional, utiliza dos índices, uno para el matriz y otro para el elemento dentro de ese matriz. </p><p>El siguiente ejemplo accede al primer elemento en el segundo matriz del ejemplo anterior.</p><div><code></code></div><p>Los dos índices de la matriz son llamados índice de fila e índice de columna.</p><p>Puedes obtener y fijar los elementos de un arreglo multidimensional utilizando el mismo par de corchetes.</p><p>Ejemplo:</p><div><code><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {</p><p style="text-indent: 2%">int[ ][ ] myArr = { {1, 2, 3}, {4}, {5, 6, 7} };</p><p style="text-indent: 2%">myArr[0][2] = 42;</p><p style="text-indent: 2%">int x = myArr[1][0]; // 4</p><br/><p style="text-indent: 2%">System.out.println(x);</p><p style="text-indent: 1%">}</p><p>}</code></div><p>El arreglo bidimensional anterior contiene tres arreglos. El primer arreglo tiene tres elementos, el segundo tiene un único elemento y el último de estos tiene tres elementos.</p><p>En Java, no estás limitado a sólo arreglos bidimensionales. Los arreglos pueden ser anidados dentro de arreglos tantos niveles como tu programa requiera. Todo lo que necesitas para declarar un arreglo con más de dos dimensiones, es añadir tantos conjuntos de corchetes vacíos como necesites. Sin embargo, estos arreglos son más difíciles de mantener.<br/>Recuerda, que todos los miembros de un arreglo deben ser del mismo tipo.</p>'                    
      classes_objects:
        lessons:
          oop:
            lesson_contents:
              oop:
                content:
                  title: 'Programación Orientada a Objetos'
                  desc: '<p>Java utiliza Programación Orientada a Objetos (OOP por sus siglas en inglés), un estilo de programación que pretende hacer el pensar al programar más cercano al pensar acerca del mundo real.</p><p>En OOP, cada objeto es una unidad independiente con una identidad única, tal como son los objetos en el mundo real.</p><p>Una manzana es un objeto; así como lo es una taza. Cada uno tiene su identidad única. Es posible tener dos tazas que se vean idénticas, pero aun así son objetos únicos y separados.</p><p>Los objetos también tienen características, las cuales son utilizadas para describirlos. Por ejemplo, un carro puede ser rojo o azul, una taza puede estar llena o vacía, y así sucesivamente. Estas características también son llamadas atributos. Un atributo describe el estado actual de un objeto.</p><p>En el mundo real, cada objeto se comporta a su propia manera. El carro se mueve, el teléfono repica, y así sucesivamente.</p><p>Lo mismo aplica a los objetos: el comportamiento es específico al tipo de objeto.</p><p>En resumen, en la programación orientada a objetos, cada objeto tiene tres dimensiones: identidad, atributos y comportamiento. <br/>Los atributos describen el estado actual del objeto y lo que el objeto es capaz de hacer es demostrado a través del comportamiento del objeto.</p>'
          classes:
            lesson_contents:
              classes:
                content:
                  title: 'Clases'
                  desc: '<p>Una clase describe lo que el objeto será, pero está separada del objeto mismo. </p><p>En otras palabras, las clases pueden ser descritas como los planos, descripciones o definiciones para un objeto. Puedes utilizar la misma clase como un esquema para crear múltiples objetos. El primer paso es definir la clase, que luego se vuelve un esquema para la creación de objetos.</p><p>Cada clase tiene un nombre y cada una es utilizada para definir atributos y comportamiento. Algunos ejemplos de atributos y comportamiento:</p><div class="img_classes_example"><img src="/assets/classes_examples.png"></div><p>En otras palabras, un objeto es una instancia de una clase.</p>'        
          methods:
            lesson_contents:
              methods:
                content:
                  title: 'Métodos'
                  desc: '<p>Los métodos definen comportamiento. Un método es una colección de declaraciones que están agrupadas juntas para ejecutar una operación. <code>System.out.println()</code> es un ejemplo de un método. </p><p>Puedes definir tus propios métodos para ejecutar tus tareas deseadas.</p><p>Vamos a considerar el siguiente código:</p><div><code><p>class MyClass {</p><p style="text-indent: 1%">static void sayHello() {</p><p style="text-indent: 2%">System.out.println("Hello World!");</p><p style="text-indent: 1%">}</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">sayHello();</p><p style="text-indent: 1%">}</p><p>}</code></div><p>El código anterior declara un método llamado "sayHello", el cual imprime un texto y luego es invocado en main.</p><p>Para invocar a un método, escribe su nombre seguido de un conjunto de paréntesis.</p>'            
              invoking_methods:
                content:
                  title: 'Invocando métodos'
                  desc: '<p>Puedes invocar un método tantas veces como sea necesario.<br/>Cuando un método es ejecutado, el código pasa a donde el método está definido, ejecuta el código dentro de él, luego regresa y procede a la siguiente línea.</p><p>Ejemplo:</p><div><code><p>class MyClass {</p><p style="text-indent: 1%">static void sayHello() {</p><p style="text-indent: 2%">System.out.println("Hello World!");</p><p style="text-indent: 1%">}</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">sayHello();</p><p style="text-indent: 2%">sayHello();</p><p style="text-indent: 2%">sayHello();</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>En casos como el anterior en los que se repite la misma cosa una y otra vez, puedes conseguir el mismo resultado utilizando loops (while o for).</p>'
              method_parameters:
                content:
                  title: 'Parámetros de métodos'
                  desc: '<p>También puedes crear un método que tome algún dato, llamado parámetro, junto con él cuando es invocado Escribe parámetros dentro de los paréntesis del método.</p><p>Por ejemplo, podemos modificar nuestro método sayHello() para que tome y tenga por salida un parámetro String.</p><div><code><p>class MyClass {</p><p style="text-indent: 1%">static void sayHello(String name) {</p><p style="text-indent: 2%">System.out.println("Hello " + name);</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">sayHello("David");</p><p style="text-indent: 2%">sayHello("Amy");</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El método anterior toma una String llamada name como parámetro, el cual es utilizado en el cuerpo del método. Luego, cuando llamamos al método, le pasamos el valor del parámetro dentro del paréntesis.<br/>Los métodos pueden tomar varios parámetros separados por comas.</p><p>Las ventajas de utilizar métodos en lugar de simples declaraciones incluyen las siguientes:<ul><li>reutilización del código: Puedes escribir un método una vez y utilizarlo múltiples veces, sin tener que reescribir el código cada vez.</li><li>parámetros: Basados en los parámetros que son pasados, los métodos pueden realizar varias acciones.</li></ul></p>'                                    
          method_return_types:
            lesson_contents:
              method_return_types:
                content:
                  title: 'Tipos de retorno para métodos'
                  desc: '<p>La palabra clave return puede ser utilizada en métodos para retornar un valor.</p><p>Por ejemplo, podemos definir un método llamado sum que retorna la suma de sus dos parámetros.</p><div><code><p>static int sum(int val1, int val2) {</p><p style="text-indent: 1%">return val1 + val2;</p><p>}</p></code></div><p>Fíjate que en la definición del método, hemos definido el tipo de retorno antes de que definieramos el nombre del método Para nuestro método sum, el tipo de retorno es int, ya que toma dos parámetros del tipo int y retorna su suma, la cual también es un int.</p><p>La palabra clave static será discutida en una próxima lección.</p><p>Ahora, podemos utilizar el método en nuestro main.</p><div><code><p>class MyClass {</p><p style="text-indent: 1%">static int sum(int val1, int val2) {</p><p style="text-indent: 2%">return val1 + val2;</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">int x = sum(2, 5);</p><p style="text-indent: 2%">System.out.println(x);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Como el método retorna un valor, lo podemos asignar a una variable.</p><p>Cuando no requieres retornar ningún valor desde tu método, utiliza la palabra clave void.<br/>Fíjate en la palabra clave void en la definición del método main - esto significa que main no retorna nada.</p><p>Fíjate una vez más en el código de nuestra lección anterior con comentarios explicativos, para que puedas entender mejor cómo funciona:</p><div><code><p>// devuelve un valor int 5</p><p>static int returnFive() {</p><p style="text-indent: 1%">return 5;</p><p>}<br/><p>// tiene un parámetro</p><p>static void sayHelloTo(String name) {</p><p style="text-indent: 1%">System.out.println("Hello " + name);</p><p>}</p><div><code><p>class Program {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">int res = max(7, 42);</p><p style="text-indent: 2%">System.out.println(res);</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">static int max(int a, int b) {</p><p style="text-indent: 2%">if(a > b) {</p><p style="text-indent: 3%">return a;</p><p style="text-indent: 2%">}</p><p style="text-indent: 2%">else {</p><p style="text-indent: 3%">return b;</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Un método puede contener un tipo de parámetro (o parámetros) y devolver otro tipo. Por ejemplo, puede tener dos doubles y devolver un int</p><br/><p>// simplemente imprime "Hello World!"</p><p>static void sayHello() {</p><p style="text-indent: 1%">System.out.println("Hello World!");</p><p>}</p></code></div><p>Habiendo obtenido conocimiento de los tipos de retorno para los métodos y parámetros, vamos a tomar otra mirada a la definición del método main.</p><div><code><p>public static void main(String[ ] args)</p></code></div><p>Esta definición indica que el método main toma un matriz de Strings como sus parámetros, y no retorna un valor.</p><p>Vamos a crear un método que tome dos parámetros del tipo int y retorne el mayor de ambos, para luego invocarlo en main:</p><div><code><p>class Program {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">int res = max(7, 42);</p><p style="text-indent: 2%">System.out.println(res);</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">static int max(int a, int b) {</p><p style="text-indent: 2%">if(a > b) {</p><p style="text-indent: 3%">return a;</p><p style="text-indent: 2%">}</p><p style="text-indent: 2%">else {</p><p style="text-indent: 3%">return b;</p><p style="text-indent: 2%">}</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Un método puede contener un tipo de parámetro (o parámetros) y devolver otro tipo. Por ejemplo, puede tener dos doubles y devolver un int</p>'       
          creating_classes_objects:
            lesson_contents:
              creating_classes:
                content:
                  title: 'Creando clases'
                  desc: '<p>Para que puedas crear tus propios objetos personalizados, debes primero crear las clases correspondientes. Esto se logra haciendo clic con el botón derecho sobre la carpeta src en Eclipse y seleccionando <b>"Create->New->Class" ("Crear->Nueva->Clase").</b> Dale un nombre a tu clase y haz clic en Finish para añadir la nueva clase a tu proyecto:</p><div class="img_classes_example"><img src="/assets/eclipse_example.png"></div><p>Como puedes ver, Eclipse ya añadió el código inicial para la clase.<br/>Ahora vamos a crear un método simple en nuestra nueva clase.</p><div><code><p><b>Animal.java</b></p><br/><p>public class Animal {</p><p style="text-indent: 1%">void bark() {</p><p style="text-indent: 2%">System.out.println("Woof-Woof");</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Hemos declarado un método bark() en nuestra clase Animal.</p><p>Ahora, para poder usar la clase y sus métodos, necesitamos declarar un objeto de esa clase.</p>'
              creating_objects:
                content:
                  title: 'Creating objects'
                  desc: '<p>Vamos ahora a nuestro main y hagamos un nuevo objeto de nuestra clase.</p><div><code><p>MyClass.java</p><br><p>public class Animal {</p><p style="text-indent: 1%">void bark() {</p><p style="text-indent: 2%">System.out.println("Woof-Woof");</p><p style="text-indent: 1%">}</p><p>}</p><br><p>class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Animal dog = new Animal();</p><p style="text-indent: 2%">dog.bark();</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Ahora, dog es un objeto del tipo Animal. Por ende podemos invocar a su método bark(), utilizando el nombre del objeto y un punto.<br/>La notación de punto es utilizada para acceder a los atributos y métodos del objeto.</p><p>¡Acabas de crear tu primer objeto!</p>'              
          class_attributes:
            lesson_contents:
              defining_attributes:
                content:
                  title: 'Definiendo atributos'
                  desc: '<p>Una clase tiene atributos y métodos. Los atributos son básicamente variables dentro de una clase.</p><p>Vamos a crear una clase llamada Vehicle, con sus atributos y métodos correspondientes.</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">int maxSpeed;</p><p style="text-indent: 1%">int wheels;</p><p style="text-indent: 1%">String color;</p><p style="text-indent: 1%">double fuelCapacity;</p><br/><p style="text-indent: 1%">void horn() {</p><p style="text-indent: 2%">System.out.println("Beep!");</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>maxSpeed, wheels, color, y fuelCapacity son los atributos de nuestra clase Vehicle, y horn() es el único método.</p><p>Puedes definir tantos atributos y métodos como sea necesario.</p>'
              creating_objects:
                content:
                  title: 'Creando objetos'
                  desc: '<p>A continuación, podemos crear múltiples objetos de nuestra clase Vehicle, y utilizar la sintaxis de punto para acceder a sus atributos y métodos.</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">int maxSpeed;</p><p style="text-indent: 1%">int wheels;</p><p style="text-indent: 1%">String color;</p><p style="text-indent: 1%">double fuelCapacity;  </p><br><p style="text-indent: 1%">void horn() {</p><p style="text-indent: 2%">System.out.println("Beep!");</p><p style="text-indent: 1%">}</p><p>}</p><br><p>class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Vehicle v1 = new Vehicle();</p><p style="text-indent: 2%">Vehicle v2 = new Vehicle();</p><p style="text-indent: 2%">v1.color = "red";</p><p style="text-indent: 2%">v2.horn();</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>¡Ejecuta el código y mira cómo funciona!</p>'                            
          access_modifiers:
            lesson_contents:
              access_modifiers:
                content:
                  title: 'Modificadores de acceso'
                  desc: '<p>Ahora vamos a revisar la palabra clave public delante del método main.</p><div><code><p>public static void main(String[ ] args)</p></code></div><p>public es un modificador de acceso, lo que significa que es utilizado para determinar el nivel de acceso. Puedes utilizar modificadores de acceso para clases, atributos y métodos.</p><p>Para las clases, los modificadores disponibles son public o el predeterminado (al dejarlo en blanco), tal y como se describe a continuación:<ul><li>public: La clase es accesible por cualquier otra clase.</li><li>predeterminado: La clase es accesible sólo por las clases pertenecientes al mismo paquete.</li></ul></p><p>Las siguientes opciones están disponibles para atributos y métodos:<ul><li>predeterminado: Una variable o método declarado sin modificador de control de acceso estará disponible para cualquier otra clase en el mismo paquete.</li><li>public: Accesible desde cualquier otra clase.</li><li>protected: Provee el mismo acceso que el modificador de acceso predeterminado, con el adicional de que las subclases pueden acceder los métodos y variables protegidas de la superclase (Subclases y superclases serán cubiertas en las próximas lecciones).</li><li>private: Accesible sólo dentro de la propia clase declarada.</li></ul></p><p>Ejemplo:</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">private int maxSpeed;</p><p style="text-indent: 1%">private int wheels;</p><p style="text-indent: 1%">private String color;</p><p style="text-indent: 1%">private double fuelCapacity;</p><br/><p style="text-indent: 1%">public void horn() {</p><p style="text-indent: 2%">System.out.println("Beep!");</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Es una buena práctica mantener privadas las variables dentro de una clase. Las variables son accesibles y modificadas utilizando Getters y Setters.</p>'          
          getters_setters:
            lesson_contents:
              getters_setters:
                content:
                  title: 'Getters y Setters'
                  desc: '<p>Getters y Setters son utilizados para proteger efectivamente tu data, particularmente cuando se crean clases. Para cada variable, el método get retorna su valor, mientras que el método set fija o establece el valor.</p><p>Los Getters comienzan con get, seguidos por el nombre de la variable, con la primera letra del nombre de la variable en mayúscula.</p><p>Los Setters comienzan con set, seguidos por el nombre de la variable, con la primera letra del nombre de la variable en mayúscula.</p><p>Ejemplo:</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">private String color;</p><br/><p style="text-indent: 1%">// Getter</p><p style="text-indent: 1%">public String getColor() {</p><p style="text-indent: 2%">return color;</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">// Setter</p><p style="text-indent: 1%">public void setColor(String c) {</p><p style="text-indent: 2%">this.color = c;</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El método getter retorna el valor del atributo.</p><p>El método setter toma un parámetro y lo asigna al atributo.</p><p>La palabra clave this es utilizada para referirse al objeto actual. Básicamente, this.color es el atributo color del objeto actual.</p><p>Una vez que nuestros getter y setter han sido definidos, podemos utilizarlos en nuestro main:</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">private String color;</p><br/><p style="text-indent: 1%">// Getter</p><p style="text-indent: 1%">public String getColor() {</p><p style="text-indent: 2%">return color;</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">// Setter</p><p style="text-indent: 1%">public void setColor(String c) {</p><p style="text-indent: 2%">this.color = c;</p><p style="text-indent: 1%">}</p><p>}</p><br/><p>class Program {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Vehicle v1 = new Vehicle();</p><p style="text-indent: 2%">v1.setColor("Red");</p><p style="text-indent: 2%">System.out.println(v1.getColor());</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Los getters y setters nos permiten tener control sobre los valores. Por ejemplo, puedes validar el valor dado en el setter antes de establecer finalmente el valor.</p><p>Los getters y setters son bloques de construcción fundamentales para la encapsulación, la cual será cubierta en el próximo módulo.</p>'      
          builders:
            lesson_contents:
              builders:
                content:
                  title: 'Constructores'
                  desc: '<p>Los constructores son métodos especiales invocados cuando un objeto es creado y son usados para inicializarlos.</p><p>Un constructor puede ser utilizado para proveer los valores iniciales de los atributos del objeto.</p><p><ul><li>El nombre del constructor debe ser el mismo que el nombre de su clase.</li><li>Un constructor no debe tener un tipo de retorno explícito.</li></ul></p><p>Ejemplo:</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">private String color;</p><p style="text-indent: 1%">Vehicle() {</p><p style="text-indent: 2%">color = "Red";</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El método Vehicle() es el constructor de nuestra clase, por lo tanto, cada vez que un objeto de esta clase sea creado, el atributo "color" será fijado a "Red".</p><p>Un constructor puede también tomar parámetros para inicializar los atributos.</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">private String color;</p><p style="text-indent: 1%">Vehicle(String c) {</p><p style="text-indent: 2%">color = c;</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Piensa en los constructores como métodos que establecerán tu class por defecto, por lo que no necesitas repetir el mismo código cada vez.</p><p>El constructor es invocado cuando creas un objeto utilizando la palabra clave new. </p><p>Ejemplo:</p><div><code><p>public class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Vehicle v = new Vehicle("Blue");</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Esto invocará al constructor, que fijará el atributo color a "Blue".</p><p>Una sola clase puede tener varios constructores con diferente número de parámetros.</p><p>Los métodos setter dentro de los constructores pueden ser utilizados para fijar los valores de atributos.</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">private String color;</p><br/><p style="text-indent: 1%">Vehicle() {</p><p style="text-indent: 2%">this.setColor("Red");</p><p style="text-indent: 1%">}</p><p style="text-indent: 1%">Vehicle(String c) {</p><p style="text-indent: 2%">this.setColor(c);</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">// Setter</p><p style="text-indent: 1%">public void setColor(String c) {</p><p style="text-indent: 2%">this.color = c;</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>La clase anterior tiene dos constructores, uno sin ningún parámetro que establece el atributo "color" a un valor predeterminado de "Red", y otro constructor que acepta un parámetro y se lo asigna al atributo.</p><p>Ahora, podemos utilizar los constructores para crear objetos de nuestra clase.</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">private String color;</p><br/><p style="text-indent: 1%">Vehicle() {</p><p style="text-indent: 2%">this.setColor("Red");</p><p style="text-indent: 1%">}</p><p style="text-indent: 1%">Vehicle(String c) {</p><p style="text-indent: 2%">this.setColor(c);</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">// Setter</p><p style="text-indent: 1%">public void setColor(String c) {</p><p style="text-indent: 2%">this.color = c;</p><p style="text-indent: 1%">}</p><p style="text-indent: 1%">// Getter</p><p style="text-indent: 1%">public String getColor() {</p><p style="text-indent: 2%">return color;</p><p style="text-indent: 1%">}</p><p>}</p><br/><br/><p>public class Program {</p><p style="text-indent: 1%">public static void main(String[] args) {  </p>      <p style="text-indent: 2%">//color will be "Red"</p><p style="text-indent: 2%">Vehicle v1 = new Vehicle();</p><br/><p style="text-indent: 2%">//color will be "Green"</p><p style="text-indent: 2%">Vehicle v2 = new Vehicle("Green");</p><br/><p style="text-indent: 2%">System.out.println(v2.getColor());</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Java automáticamente provee el constructor predeterminado, para que todas las clases tengan un constructor, sin importar que uno sea especificado o no.</p>'      
          value_types_referenced:
            lesson_contents:
              types_by_value:
                content:
                  title: 'Tipos por valor'
                  desc: '<p>Los tipos por valor son los tipos básicos e incluyen byte, short, int, long, float, double, boolean y char.<br/>Estos tipos de datos almacenan los valores asignados a ellos en la ubicación de memoria correspondiente.</p><p>Por lo tanto, cuando los pasas a un método, básicamente estás operando sobre el valor de la variable en lugar de la variable misma.</p><p>Ejemplo:</p><div><code><p>public class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">int x = 5;</p><p style="text-indent: 2%">addOneTo(x);</p><p style="text-indent: 2%">System.out.println(x);</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">static void addOneTo(int num) {</p><p style="text-indent: 2%">num = num + 1;</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El método del ejemplo anterior toma el valor de su parámetro, lo cual es el por qué la variable original no es afectada y continúa teniendo un valor de 5.</p>'
              rates_by_referencing:
                content:
                  title: 'Tipos por referenciado'
                  desc: '<p>Un tipo referenciado almacena una referencia (o dirección) a la ubicación de memoria donde la data correspondiente es almacenada.</p><p>Cuando creas un objeto utilizando el constructor, estás creando una variable referenciada.</p><p>Por ejemplo, considera tener una clase Person definida:</p><div><code><p>public class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Person j;</p><p style="text-indent: 2%">j = new Person("John");</p><p style="text-indent: 2%">j.setAge(20);</p><p style="text-indent: 2%">celebrateBirthday(j);</p><p style="text-indent: 2%">System.out.println(j.getAge());</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">static void celebrateBirthday(Person p) {</p><p style="text-indent: 2%">p.setAge(p.getAge() + 1);</p><p style="text-indent: 1%">}</p><p>}</p><br/><br/><p>public class Person {</p><p style="text-indent: 1%">private String name;</p><p style="text-indent: 1%">private int age;</p><br/><p style="text-indent: 1%">Person (String n) {</p><p style="text-indent: 2%">this.name = n;</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">public int getAge() {</p><p style="text-indent: 2%">return age;</p><p style="text-indent: 1%">}</p><br/><p style="text-indent: 1%">public void setAge(int a) {</p><p style="text-indent: 2%">this.age = a;</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>El método celebrateBirthday toma un objeto Person como su parámetro e incrementa su atributo.<br/>Como j es un tipo referenciado, el método afecta al objeto mismo, y puede cambiar el valor actual de su atributo.<br/>Los Matrices y Strings también son tipos de datos referenciados.</p>'                    
          static:
            lesson_contents:
              static:
                content:
                  title: 'Static'
                  desc: '<p>Cuando declaras una variable o un método como static (estático), pertenecerá a la clase, en lugar de a una instancia específica. Esto significa que sólo existe una instancia de un miembro estático, aún si creas múltiples objetos de la clase o si no creas ninguno. Será compartida por todos los objetos.</p><div><code><p>public class Counter {</p><p style="text-indent: 1%">public static int COUNT=0;</p><p style="text-indent: 1%">Counter() {</p><p style="text-indent: 2%">COUNT++;</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>La variable COUNT será compartida por todos los objetos de esa clase.</p><p>Ahora, podemos crear objetos de nuestra clase Counter en main y acceder a la variable static.</p><div><code><p>public class Counter {</p><p style="text-indent: 1%">public static int COUNT=0;</p><p style="text-indent: 1%">Counter() {</p><p style="text-indent: 2%">COUNT++;</p><p style="text-indent: 1%">}</p><p>}</p><br/><p>public class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Counter c1 = new Counter();</p><p style="text-indent: 2%">Counter c2 = new Counter();</p><p style="text-indent: 2%">System.out.println(Counter.COUNT);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>La salida es 2, porque la variable COUNT es estática y se incrementa en uno cada vez que un nuevo objeto de la clase Counter es creado. En el código anterior, hemos creado dos objetos.</p><p>También puedes acceder a la variable estática utilizando cualquier objeto de esa clase, como c1.COUNT.</p><p>Es una práctica común utilizar mayúsculas cuando nombramos una variable estática, aunque esto no es obligatorio.</p><p>El mismo concepto aplica a los métodos estáticos.</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">public static void horn() {</p><p style="text-indent: 2%">System.out.println("Beep");</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Ahora, el método "horn" puede ser invocado sin tener que crear un objeto:</p><div><code><p>public class Vehicle {</p><p style="text-indent: 1%">public static void horn() {</p><p style="text-indent: 2%">System.out.println("Beep");</p><p style="text-indent: 1%">}</p><p>}</p><br/><p>public class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Vehicle.horn();</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Otro ejemplo de métodos estáticos son aquellos de la clase Math, que es la razón del por qué puedes invocarlos sin tener que crear un objeto Math.</p><p>Igualmente, método main debe ser siempre estático.</p>'         
          final:
            lesson_contents:
              final:
                content:
                  title: 'Final'
                  desc: '<p>Utiliza la palabra clave final para marcar una variable como constante, de tal forma que sólo pueda ser asignada una vez.</p><div><code><p>class MyClass {</p><p style="text-indent: 1%">public static final double PI = 3.14; </p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">System.out.println(PI);</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Ahora PI es una constante. Cualquier intento de asignarle un valor causará un error.</p><p>Los métodos y clases pueden también ser marcados con final. Esto sirve para restringir métodos para que no puedan ser sobrecargados y en las clases para que no se puedan hacer subclases.<br/>Estos conceptos serán cubiertos en el siguiente módulo.</p>'       
          packages:
            lesson_contents:
              packages:
                content:
                  title: 'Paquetes'
                  desc: '<p>Los paquetes son utilizados para evitar conflictos con los nombres y para controlar acceso a las clases.<br/>Un paquete puede ser definido como un grupo hecho de clases de tipo similar, junto con sub-paquetes. </p><p>Crear un paquete en Java es bastante fácil. Simplemente haz clic con el botón derecho sobre tu directorio src y luego clic en New->Package (Nuevo->Paquete). Dale un nombre a tu paquete y haz clic en Finish. </p><p>Te darás cuenta que el nuevo paquete aparece en el directorio del proyecto. Ahora puedes mover y crear clases dentro del paquete. Hemos movido nuestras clases Vehicle, Counter y Animal al paquete samples.</p><div class="img_classes_example"><img src="/assets/eclipse_packages.png"></div><p>Cuando mueves/creas una clase en tu paquete, el siguiente código aparecerá en la parte superior de la lista de archivos.</p><div><code><p>package samples;</p></code></div><p>Esto indica el paquete al cual pertenece la clase.</p><p>Ahora, necesitamos importar las clases que están dentro de un paquete en nuestro main para poder utilizarlas.</p><p>El siguiente ejemplo muestra cómo utilizar la clase Vehicle del paquete samples.</p><div><code><p>class MyClass {</p><p style="text-indent: 1%">public static void main(String[ ] args) {</p><p style="text-indent: 2%">Vehicle v1 = new Vehicle();</p><p style="text-indent: 2%">v1.horn();</p><p style="text-indent: 1%">}</p><p>}</p></code></div><p>Dos resultados principalmente ocurren cuando una clase es colocada en un paquete.<br/> Primero, el nombre del paquete se convierte en parte del nombre de la clase. <br/>Segundo, el nombre del paquete debe coincidir con la estructura de directorio donde el archivo de clase correspondiente está ubicado.</p><p>Utiliza un comodín para importar todas las clases de un paquete.<br/>Por ejemplo, import samples.* importará todas las clases en el paquete "samples".</p>'
